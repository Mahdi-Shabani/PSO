# 📝 تسک شماره یک – پیاده‌سازی الگوریتم PSO روی تابع ساده

## 🎯 هدف
در قدم اول باید الگوریتم **بهینه‌سازی ازدحام ذرات (PSO)** را روی یک مسئله ساده ریاضی پیاده‌سازی کنیم.  
ایده این تسک این است که قبل از ورود به مسائل پیچیده‌تر مثل ماشین‌لرنینگ، بفهمیم **خود الگوریتم PSO چگونه کار می‌کند**.

---

## 📌 مسئله مورد نظر
یک تابع ساده داریم:

```math
f(x, y) = x^2 + y^2
```
هدف: پیدا کردن نقطه‌ای که مقدار تابع در آن کمترین مقدار ممکن باشد.
جواب واقعی این تابع در نقطه (0,0) است. الگوریتم PSO باید بتواند خودش این نقطه را پیدا کند.

⚙️ ایده الگوریتم PSO
تعدادی ذره (Particle) را در فضا پخش می‌کنیم.
هر ذره:
موقعیت و سرعت دارد.
بهترین تجربه فردی خود (pBest) را یاد می‌گیرد.
بهترین تجربه جمعی گروه (gBest) را می‌شناسد.
ذره‌ها در هر مرحله:
موقعیتشان را با توجه به pBest و gBest به‌روز می‌کنند.
به مرور به سمت جواب بهینه (نقطه مینیمم) همگرا می‌شوند.


---

## 📊 روند کار فایل‌ها
1. **objective_function.py** → تعریف تابع هدف KATEX_INLINE_OPENf(x,y)=x^2+y^2KATEX_INLINE_CLOSE  
2. **particle.py** → ساختار و ویژگی‌های یک ذره (position, velocity, pBest)  
3. **pso.py** → اجرای الگوریتم PSO شامل:

    ارزیابی ذرات با تابع هدف  
    به‌روزرسانی pBest و gBest  
    آپدیت موقعیت و سرعت  
5. **main.py** → اجرای پروژه و نمایش خروجی نهایی  

---

## ▶️ نحوه اجرا
از مسیر پروژه دستور زیر را اجرا کنید:

```bash
cd PSO_Project
python main.py
```
📊 نمونه خروجی (هر بار متفاوت چون تصادفی‌ست)
```
Iteration 0: gBest = 1.75
Iteration 10: gBest = 0.002
Iteration 20: gBest = 2.3e-06
Iteration 30: gBest = 2.6e-09
...
```
✅ نتیجه نهایی:
```
بهترین موقعیت پیدا شده = [ 1.8e-12  -2.5e-12]
مقدار تابع در این نقطه = 9.9e-24
```
 خروجی نشان می‌دهد الگوریتم PSO به نقطه بهینه نزدیک شده و کمینه تابع را عملاً پیدا کرده است.

 
در تسک شماره یک، الگوریتم PSO را روی یک تابع ساده (Sphere Function) پیاده‌سازی کردیم.
با شبیه‌سازی حرکت ذرات و استفاده از بهترین تجربه فردی (pBest) و جمعی (gBest)، الگوریتم موفق شد نقطه کمینه واقعی تابع یعنی (0,0) را پیدا کند.
این مرحله پایه‌ای است برای استفاده از PSO در مسائل واقعی‌تر مثل انتخاب ویژگی در یادگیری ماشین.
